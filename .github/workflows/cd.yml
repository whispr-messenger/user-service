name: CD Pipeline

on:
  workflow_run:
    workflows: [üöÄ CI Pipeline]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Commit SHA to deploy (leave empty for latest)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/user-service

jobs:
  update-deployment:
    if: ${{ (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'push') || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    name: Update Deployment Manifest

    permissions:
      contents: write
      packages: read

    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.ACTIONS_CD }}
          private_key: ${{ secrets.ACTIONS_CD_PRIVATE_KEY }}

      - name: Checkout user-service
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ steps.generate_token.outputs.token }}

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Validate and determine commit SHA
        id: validate_commit
        run: |
          # Determine the commit SHA based on trigger type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger - use input or current commit
            if [ -n "${{ inputs.commit_sha }}" ]; then
              COMMIT_SHA="${{ inputs.commit_sha }}"
              echo "Validating manually provided commit SHA: $COMMIT_SHA"
              
              # Validate SHA format (40 hex characters for full SHA or 7+ for short SHA)
              if ! echo "$COMMIT_SHA" | grep -qE '^[a-fA-F0-9]{7,40}$'; then
                echo "‚ùå Error: Invalid commit SHA format. Must be 7-40 hexadecimal characters."
                exit 1
              fi
              
              # Verify the commit exists in the repository
              if ! git rev-parse --verify "${COMMIT_SHA}^{commit}" >/dev/null 2>&1; then
                echo "‚ùå Error: Commit SHA '${COMMIT_SHA}' does not exist in the repository."
                echo "Please provide a valid commit SHA from the main branch."
                exit 1
              fi
              
              # Get the full SHA if a short SHA was provided
              COMMIT_SHA=$(git rev-parse --verify "${COMMIT_SHA}^{commit}")
              echo "‚úÖ Commit SHA validated successfully"
              echo "Using manually provided commit SHA: $COMMIT_SHA"
            else
              COMMIT_SHA="${{ github.sha }}"
              echo "Using current commit SHA: $COMMIT_SHA"
            fi
          else
            # Automatic trigger from CI workflow
            COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
            # If empty, use github.sha as fallback
            if [ -z "$COMMIT_SHA" ]; then
              COMMIT_SHA="${{ github.sha }}"
              echo "Using github.sha as fallback: $COMMIT_SHA"
            fi
          fi

          # Store COMMIT_SHA as output for use in subsequent steps
          echo "commit_sha=${COMMIT_SHA}" >> $GITHUB_OUTPUT

      - name: Verify image exists in registry
        run: |
          COMMIT_SHA="${{ steps.validate_commit.outputs.commit_sha }}"
          SHORT_SHA=$(printf "%.7s" "$COMMIT_SHA")
          IMAGE_TAG="sha-${SHORT_SHA}"
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
          FULL_IMAGE=$(echo "${FULL_IMAGE}" | tr '[:upper:]' '[:lower:]')
          
          echo "Verifying image existence: ${FULL_IMAGE}"
          # We use docker manifest inspect which is available in modern docker versions
          if ! docker manifest inspect "${FULL_IMAGE}" > /dev/null 2>&1; then
            echo "‚ùå Error: Docker image ${FULL_IMAGE} not found in registry."
            echo "The CI pipeline might have failed to build or push the image for this commit."
            exit 1
          fi
          echo "‚úÖ Image found in registry"

      - name: Checkout infrastructure repository
        uses: actions/checkout@v4
        with:
          repository: whispr-messenger/infrastructure
          ref: main
          token: ${{ steps.generate_token.outputs.token }}

      - name: Validate deployment manifest path
        run: |
          MANIFEST_PATH="argocd/k8s/whispr/user-service/deployment.yaml"
          if [ ! -f "$MANIFEST_PATH" ]; then
            echo "‚ùå Error: Deployment manifest not found at $MANIFEST_PATH"
            echo "Please verify the path in the infrastructure repository."
            exit 1
          fi
          echo "‚úÖ Deployment manifest found at $MANIFEST_PATH"

      - name: Update image tag in deployment
        id: update_image
        run: |
          # Use the validated commit SHA from the previous step
          COMMIT_SHA="${{ steps.validate_commit.outputs.commit_sha }}"
          
          # Extract short SHA safely using printf (7 characters, matching docker metadata-action default)
          SHORT_SHA=$(printf "%.7s" "$COMMIT_SHA")
          
          # Use the short SHA tag format that matches the CI docker workflow
          IMAGE_TAG="sha-${SHORT_SHA}"

          # Build the full image reference with lowercase (OCI requirement)
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
          FULL_IMAGE=$(echo "${FULL_IMAGE}" | tr '[:upper:]' '[:lower:]')

          echo "Commit SHA: $COMMIT_SHA"
          echo "Short SHA: $SHORT_SHA"
          echo "Image tag: $IMAGE_TAG"
          echo "Updating deployment image to: ${FULL_IMAGE}"

          # Update the deployment manifest in the infrastructure repository
          yq -i ".spec.template.spec.containers[0].image = \"${FULL_IMAGE}\"" argocd/k8s/whispr/user-service/deployment.yaml

      - name: Verify update
        run: |
          echo "Updated deployment manifest:"
          yq '.spec.template.spec.containers[0].image' argocd/k8s/whispr/user-service/deployment.yaml

      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are changes to commit
          if git diff --quiet argocd/k8s/whispr/user-service/deployment.yaml; then
            echo "No changes to commit"
            exit 0
          fi

          # Use the validated commit SHA determined in the previous step
          COMMIT_SHA="${{ steps.validate_commit.outputs.commit_sha }}"
          SHORT_SHA=$(printf "%.7s" "$COMMIT_SHA")
          
          # Create a new branch with a generic, reusable name
          BRANCH_NAME="deploy-user-service-${SHORT_SHA}"
          echo "Creating and pushing to branch: ${BRANCH_NAME}"
          git checkout -b "${BRANCH_NAME}"
          
          # Build commit message based on trigger type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            COMMIT_MSG="üîß chore(deploy/user-service): update image to ${SHORT_SHA} (manual trigger)"
          else
            COMMIT_MSG="üîß chore(deploy/user-service): update image to ${SHORT_SHA}"
          fi

          git add argocd/k8s/whispr/user-service/deployment.yaml
          git commit -m "${COMMIT_MSG}"

          git push https://x-access-token:${{ steps.generate_token.outputs.token }}@github.com/whispr-messenger/infrastructure.git "${BRANCH_NAME}"